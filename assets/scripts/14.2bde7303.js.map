{"version":3,"sources":["webpack:///./src/infrastructure/EnvVarConfigRegistry.ts","webpack:///./src/lib/validators/gitHubApiResourceValidators.ts","webpack:///./src/infrastructure/GetRepoImpl.ts","webpack:///./src/infrastructure/persistence/double/TaskRepositoryFakeImpl.ts","webpack:///./src/container.ts","webpack:///./src/lib/asserters/commonAsserters.ts","webpack:///./src/lib/validators/stringValidators.ts"],"names":["EnvVarConfigRegistry","injectable","env","BASE_NAME","process","GITHUB_API_URL","name","value","this","undefined","Error","typed","asRepository","asObject","input","full_name","asString","html_url","asUrl","asUnsuccessfulResponse","message","documentation_url","optional","GetRepoImpl","config","inject","owner","repo","gitHubApiUrl","get","fetch","method","parameterizedEndpoint","params","headers","Accept","status","response","body","successful","TaskRepositoryFakeImpl","tasks","i","localStorage","length","key","shouldBePresent","seriarized","getItem","task","Task","deserialize","push","List","taskId","setItem","id","serialize","removeItem","container","Container","bind","to","Service","toSelf","ChessService","CounterService","IoService","LocaleSelectorService","ReminderService","it","shouldBeNullable","asBoundedLengthString","lowerBound","Infinity","upperBound","inputAsString","ValidationError","isUrl"],"mappings":"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","file":"assets/scripts/14.2bde7303.js","sourcesContent":["import { injectable } from 'inversify'\n\nimport ConfigRegistry, { ConfigKey } from '~/config/ConfigRegistry'\nimport typed from '~/lib/typed'\n\n@injectable()\nexport default class EnvVarConfigRegistry implements ConfigRegistry {\n  private env: Record<ConfigKey, string | undefined> = {\n    BASE_NAME: process.env.BASE_NAME,\n    GITHUB_API_URL: process.env.GITHUB_API_URL,\n  }\n\n  /**\n   * @throws {Error} if not found.\n   */\n  public get(name: ConfigKey) {\n    const value = this.env[name]\n\n    if (value === undefined) {\n      throw new Error(typed<[string]>`The ${ name } environment variable does not exist.`) // TODO:\n    }\n\n    return value\n  }\n}\n","import { asObject, asString, optional } from './commonValidators'\nimport { asUrl } from './stringValidators'\n\nexport function asGetRepoResponse(input: unknown): GitHubApi.GetRepoResponse {\n  return asRepository(input)\n}\n\nconst asRepository = asObject<GitHubApi.Repository>('a Repository', (input) => ({\n  full_name: asString(input.full_name),\n  html_url: asUrl(input.html_url),\n}))\n\nexport const asUnsuccessfulResponse = asObject<GitHubApi.UnsuccessfulResponse>('an UnsuccessfulResponse', (input) => ({\n  message: asString(input.message),\n  documentation_url: optional(asString)(input.documentation_url),\n}))\n","import { inject, injectable } from 'inversify'\n\nimport ConfigRegistry from '~/config/ConfigRegistry'\nimport fetch from '~/lib/fetch'\nimport typed from '~/lib/typed'\nimport { asGetRepoResponse, asUnsuccessfulResponse } from '~/lib/validators/gitHubApiResourceValidators'\nimport GetRepo, { GetRepoInput, GetRepoOutput } from '~/useCase/GetRepo'\n\n@injectable()\nexport default class GetRepoImpl implements GetRepo {\n  constructor(\n    @inject('EnvVarConfig') private config: ConfigRegistry\n  ) {}\n\n  public async apply({ owner, repo }: GetRepoInput): Promise<GetRepoOutput> {\n    const gitHubApiUrl = this.config.get('GITHUB_API_URL')\n\n    const { response: { status }, body } = await fetch({\n      method: 'GET',\n      parameterizedEndpoint: typed<[string]>`${ gitHubApiUrl }/repos/:owner/:repo`,\n      params: { owner, repo },\n      headers: {\n        Accept: 'application/vnd.github.v3+json',\n      },\n    })\n\n    if (status === 200) {\n      return {\n        successful: true,\n        response: {\n          status,\n          body: asGetRepoResponse(body),\n        },\n      }\n    } else {\n      return {\n        successful: false,\n        response: {\n          status,\n          body: asUnsuccessfulResponse(body),\n        },\n      }\n    }\n  }\n}\n","import { List } from 'immutable'\nimport { injectable } from 'inversify'\n\nimport Task from '~/domain/entity/Task'\nimport TaskRepository from '~/domain/repository/TaskRepository'\nimport TaskId from '~/domain/vo/TaskId'\nimport { shouldBePresent } from '~/lib/asserters/commonAsserters'\n\n// TODO: namespace in localStorage\n@injectable()\nexport default class TaskRepositoryFakeImpl implements TaskRepository {\n  public async list() {\n    const tasks = []\n\n    // tslint:disable-next-line:no-loop-statement no-let\n    for (let i = 0; i < localStorage.length; ++i) {\n      const key = localStorage.key(i)\n\n      shouldBePresent(key)\n\n      const seriarized = localStorage.getItem(key)\n\n      shouldBePresent(seriarized)\n\n      // tslint:disable-next-line:no-let\n      let task: Task\n\n      try {\n        task = Task.deserialize(seriarized)\n      } catch (error) {\n        continue\n      }\n\n      // tslint:disable-next-line:no-array-mutation\n      tasks.push(task)\n    }\n\n    return List(tasks)\n  }\n\n  public async findById(taskId: TaskId) {\n    const seriarized = localStorage.getItem(taskId.value)\n\n    if (seriarized === null) {\n      throw new Error // TODO:\n    }\n\n    return Task.deserialize(seriarized)\n  }\n\n  public async store(task: Task) {\n    return localStorage.setItem(task.id.value, task.serialize())\n  }\n\n  public async remove(task: Task) {\n    return localStorage.removeItem(task.id.value)\n  }\n}\n","import { Container } from 'inversify'\n\nimport ConfigRegistry from './config/ConfigRegistry'\nimport TaskRepository from './domain/repository/TaskRepository'\nimport EnvVarConfigRegistry from './infrastructure/EnvVarConfigRegistry'\nimport GetRepoImpl from './infrastructure/GetRepoImpl'\nimport TaskRepositoryFakeImpl from './infrastructure/persistence/double/TaskRepositoryFakeImpl' // TODO:\nimport Service from './redux'\nimport { ChessService } from './redux/modules/chess'\nimport { CounterService } from './redux/modules/counter'\nimport { IoService } from './redux/modules/io'\nimport LocaleSelectorService from './redux/modules/localeSelector'\nimport ReminderService from './redux/modules/reminder'\nimport GetRepo from './useCase/GetRepo'\n\nconst container = new Container\n\ncontainer.bind<ConfigRegistry>('EnvVarConfig').to(EnvVarConfigRegistry)\ncontainer.bind<GetRepo>('GetRepo').to(GetRepoImpl)\ncontainer.bind<TaskRepository>('TaskRepository').to(TaskRepositoryFakeImpl)\ncontainer.bind(Service).toSelf()\ncontainer.bind(ChessService).toSelf()\ncontainer.bind(CounterService).toSelf()\ncontainer.bind(IoService).toSelf()\ncontainer.bind(LocaleSelectorService).toSelf()\ncontainer.bind(ReminderService).toSelf()\n\nexport default container\n","export function shouldBePresent<T>(it: T | null | undefined): asserts it is T {\n  if (it == null) {\n    throw new Error //\n  }\n}\n\nexport function shouldBeNullable<T>(it: T | null | undefined): asserts it is null | undefined {\n  if (it != null) {\n    throw new Error //\n  }\n}\n","import assert from 'assert'\n\nimport { isUrl } from '~/lib/guards/stringGuards'\nimport typed from '~/lib/typed'\nimport ValidationError from './ValidationError'\nimport { asString } from './commonValidators'\n\nexport const asBoundedLengthString = ({\n  lowerBound = -Infinity,\n  upperBound = Infinity,\n}: {\n  lowerBound?: number\n  upperBound?: number\n}) => (input: unknown) => {\n  assert(lowerBound <= upperBound)\n\n  const inputAsString = asString(input)\n\n  if (lowerBound <= inputAsString.length && inputAsString.length <= upperBound) {\n    return inputAsString\n  }\n\n  throw new ValidationError(\n    typed<[string, number, number]>`${ inputAsString } is not between ${ lowerBound } and ${ upperBound } characters.`,\n    'asBoundedLengthStringErrorMessage',\n    {\n      input: inputAsString.length,\n      lowerBound,\n      upperBound,\n    }\n  )\n}\n\nexport function asUrl(input: unknown): string.Url {\n  const inputAsString = asString(input)\n\n  if (!isUrl(inputAsString)) {\n    throw new ValidationError(typed<[string]>`${ inputAsString } is not a URL.`)\n  }\n\n  return inputAsString\n}\n"],"sourceRoot":""}