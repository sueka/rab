{"version":3,"sources":["webpack://rap/./src/infrastructure/EnvVarConfigRegistry.ts","webpack://rap/./src/lib/validators/gitHubApiResourceValidators.ts","webpack://rap/./src/infrastructure/GetRepoImpl.ts","webpack://rap/./src/infrastructure/persistence/double/TaskRepositoryFakeImpl.ts","webpack://rap/./src/container.ts","webpack://rap/./src/lib/guards/commonGuards.ts","webpack://rap/./src/lib/validators/stringValidators.ts","webpack://rap/./src/lib/guards/stringGuards.ts"],"names":["EnvVarConfigRegistry","injectable","configMap","DEBUG","optional","isOneOf","process","BASE_NAME","asRequired","GITHUB_API_URL","USER_SERVICE_URL","name","this","asGetRepoResponse","input","asRepository","asObject","full_name","asString","html_url","asUrl","asUnsuccessfulResponse","message","documentation_url","GetRepoImpl","config","inject","owner","repo","gitHubApiUrl","get","fetch","generatePath","typed","headers","Accept","response","status","json","body","successful","TaskRepositoryFakeImpl","tasks","i","localStorage","length","key","shouldBePresent","seriarized","getItem","task","Task","push","List","taskId","value","Error","setItem","id","serialize","removeItem","container","Container","bind","to","Service","toSelf","ChessService","CounterService","IoService","LocaleSelectorService","ReminderService","UserAuthnService","options","some","option","isT","undefined","asBoundedLengthString","lowerBound","Infinity","upperBound","inputAsString","ValidationError","URL","error","isUrl"],"mappings":"2NAOqBA,GADpBC,iB,kDAESC,UAA+B,CACrCC,MAAK,WAAEC,SAASC,QAAQ,IAAK,OAAQ,OAAQ,QAAtCD,CAA+CE,GAAYH,cAA7D,SACLI,WAAWC,OAAWF,QACtBG,gBAAgBD,OAAWF,0BAC3BI,kBAAkBF,OAAWF,2B,+BAM/B,SAAgCK,GAC9B,OAAOC,KAAKV,UAAUS,O,iHChBnB,SAASE,EAAkBC,GAChC,OAAOC,EAAaD,GAGtB,I,MAAMC,GAAeC,QAA+B,gBAAgB,SAACF,GAAD,MAAY,CAC9EG,WAAWC,QAASJ,EAAMG,WAC1BE,UAAUC,OAAMN,EAAMK,cAGXE,GAAyBL,QAAyC,2BAA2B,SAACF,GAAD,MAAY,CACpHQ,SAASJ,QAASJ,EAAMQ,SACxBC,mBAAmBnB,QAASc,KAATd,CAAmBU,EAAMS,uBCJzBC,GADpBvB,iB,cAEC,cAEE,iBADgCwB,S,gBAA/BC,YAAO,eAAPA,C,0DAGH,kGAAqBC,EAArB,EAAqBA,MAAOC,EAA5B,EAA4BA,KACpBC,EAAejB,KAAKa,OAAOK,IAAI,kBADvC,UAGyBC,SAAMC,SAAaC,OAAA,IAAD,mCAAoBJ,GAAoC,CAAEF,QAAOC,SAAS,CACjHM,QAAS,CACPC,OAAQ,oCALd,UAS0B,OANlBC,EAHR,QASeC,OATf,6BAagBD,EAASC,OAbzB,KAccxB,EAdd,UAcsCuB,EAASE,OAd/C,qDAaQD,OAbR,KAcQE,KAdR,yBAWMC,YAAY,EACZJ,SAZN,2BAqBgBA,EAASC,OArBzB,KAsBchB,EAtBd,UAsB2Ce,EAASE,OAtBpD,qDAqBQD,OArBR,KAsBQE,KAtBR,yBAmBMC,YAAY,EACZJ,SApBN,wD,yFCLmBK,GADpBxC,iB,oGAEC,4FACQyC,EAAQ,GAGLC,EAAI,EAJf,YAIkBA,EAAIC,aAAaC,QAJnC,iBAKUC,EAAMF,aAAaE,IAAIH,IAE7BI,OAAgBD,GAEVE,EAAaJ,aAAaK,QAAQH,IAExCC,OAAgBC,GAGZE,OAdR,WAiBMA,EAAOC,gBAAiBH,GAjB9B,yFAuBIN,EAAMU,KAAKF,GAvBf,UAI6CP,EAJ7C,iDA0BSU,QAAKX,IA1Bd,0D,oFA6BA,WAAsBY,GAAtB,0EAGqB,QAFbN,EAAaJ,aAAaK,QAAQK,EAAOC,QADjD,sBAIU,IAAIC,MAJd,gCAOSL,gBAAiBH,IAP1B,2C,kFAUA,WAAmBE,GAAnB,0FACSN,aAAaa,QAAQP,EAAKQ,GAAGH,MAAOL,EAAKS,cADlD,2C,mFAIA,WAAoBT,GAApB,0FACSN,aAAagB,WAAWV,EAAKQ,GAAGH,QADzC,2C,qICtCIM,EAAY,IAAIC,YAEtBD,EAAUE,KAAqB,gBAAgBC,GAAGhE,GAClD6D,EAAUE,KAAc,WAAWC,GAAGxC,GACtCqC,EAAUE,KAAqB,kBAAkBC,GAAGvB,GACpDoB,EAAUE,KAAKE,MAASC,SACxBL,EAAUE,KAAKI,MAAcD,SAC7BL,EAAUE,KAAKK,MAAgBF,SAC/BL,EAAUE,KAAKM,MAAWH,SAC1BL,EAAUE,KAAKO,MAAuBJ,SACtCL,EAAUE,KAAKQ,MAAiBL,SAChCL,EAAUE,KAAKS,MAAkBN,SAEjC,S,2FC3BO,IAAM7D,EAAU,sCAA+BoE,EAA/B,yBAA+BA,EAA/B,uBAA8C,SAAC3D,GAAD,OAAwC2D,EAAQC,MAAK,SAACC,GAAD,OAAYA,IAAW7D,OAEpIV,EAAW,SAAiCwE,GAAjC,OAAmE,SAAC9D,GAC1F,YAAc+D,IAAV/D,GAIG8D,EAAI9D,M,2JCFAgE,EAAwB,SAAC,GAAD,QACnCC,kBADmC,OACrBC,IADqB,MAEnCC,kBAFmC,MAEtBD,IAFsB,SAM/B,SAAClE,GAGL,IAAMoE,GAAgBhE,QAASJ,GAE/B,GAAIiE,GAAcG,EAAcrC,QAAUqC,EAAcrC,QAAUoC,EAChE,OAAOC,EAGT,MAAM,IAAIC,KACRlD,OADI,2DAC+BiD,EAAkCH,EAAoBE,GACzF,oCACA,CACEnE,MAAOoE,EAAcrC,OACrBkC,aACAE,iBAKC,SAAS7D,EAAMN,GACpB,IAAMoE,GAAgBhE,QAASJ,GAE/B,ICpCK,SAAeA,GACpB,IAIE,OAFA,IAAIsE,IAAItE,IAED,EACP,MAAOuE,GACP,OAAO,GD6BJC,CAAMJ,GACT,MAAM,IAAIC,KAAgBlD,OAApB,kCAAuCiD,IAG/C,OAAOA","file":"assets/scripts/670.3d7bf034.js","sourcesContent":["import { injectable } from 'inversify'\n\nimport ConfigRegistry, { ConfigKey, ConfigKeyValueMap } from '~/config/ConfigRegistry'\nimport { isOneOf, optional } from '~/lib/guards/commonGuards'\nimport { asRequired } from '~/lib/validators/commonValidators'\n\n@injectable()\nexport default class EnvVarConfigRegistry implements ConfigRegistry {\n  private configMap: ConfigKeyValueMap = {\n    DEBUG: optional(isOneOf('1', 'TRUE', 'True', 'true'))(process.env.DEBUG) ?? false,\n    BASE_NAME: asRequired(process.env.BASE_NAME),\n    GITHUB_API_URL: asRequired(process.env.GITHUB_API_URL),\n    USER_SERVICE_URL: asRequired(process.env.USER_SERVICE_URL),\n  }\n\n  /**\n   * @throws [[Error]] if not found.\n   */\n  public get<T extends ConfigKey>(name: T) {\n    return this.configMap[name]\n  }\n}\n","import { asObject, asString, optional } from './commonValidators'\nimport { asUrl } from './stringValidators'\n\nexport function asGetRepoResponse(input: unknown): GitHubApi.GetRepoResponse {\n  return asRepository(input)\n}\n\nconst asRepository = asObject<GitHubApi.Repository>('a Repository', (input) => ({\n  full_name: asString(input.full_name),\n  html_url: asUrl(input.html_url),\n}))\n\nexport const asUnsuccessfulResponse = asObject<GitHubApi.UnsuccessfulResponse>('an UnsuccessfulResponse', (input) => ({\n  message: asString(input.message),\n  documentation_url: optional(asString)(input.documentation_url),\n}))\n","import { inject, injectable } from 'inversify'\nimport { generatePath } from 'react-router'\n\nimport ConfigRegistry from '~/config/ConfigRegistry'\nimport fetch from '~/lib/fetch'\nimport typed from '~/lib/typed'\nimport { asGetRepoResponse, asUnsuccessfulResponse } from '~/lib/validators/gitHubApiResourceValidators'\nimport GetRepo, { GetRepoInput, GetRepoOutput } from '~/useCase/GetRepo'\n\n@injectable()\nexport default class GetRepoImpl implements GetRepo {\n  constructor(\n    @inject('EnvVarConfig') private config: ConfigRegistry\n  ) {}\n\n  public async apply({ owner, repo }: GetRepoInput): Promise<GetRepoOutput> {\n    const gitHubApiUrl = this.config.get('GITHUB_API_URL')\n\n    const response = await fetch(generatePath(typed<[string]>`${ gitHubApiUrl }/repos/:owner/:repo`, { owner, repo }), {\n      headers: {\n        Accept: 'application/vnd.github.v3+json',\n      },\n    })\n\n    if (response.status === 200) {\n      return {\n        successful: true,\n        response: {\n          status: response.status,\n          body: asGetRepoResponse(await response.json()),\n        },\n      }\n    } else {\n      return {\n        successful: false,\n        response: {\n          status: response.status,\n          body: asUnsuccessfulResponse(await response.json()),\n        },\n      }\n    }\n  }\n}\n","import { List } from 'immutable'\nimport { injectable } from 'inversify'\n\nimport Task from '~/domain/entity/Task'\nimport TaskRepository from '~/domain/repository/TaskRepository'\nimport TaskId from '~/domain/vo/TaskId'\nimport { shouldBePresent } from '~/lib/asserters/commonAsserters'\n\n// TODO: Create namespace in localStorage\n@injectable()\nexport default class TaskRepositoryFakeImpl implements TaskRepository {\n  public async list() {\n    const tasks = []\n\n    // tslint:disable-next-line:no-loop-statement no-let\n    for (let i = 0; i < localStorage.length; ++i) {\n      const key = localStorage.key(i)\n\n      shouldBePresent(key)\n\n      const seriarized = localStorage.getItem(key)\n\n      shouldBePresent(seriarized)\n\n      // tslint:disable-next-line:no-let\n      let task: Task\n\n      try {\n        task = Task.deserialize(seriarized)\n      } catch (error: unknown) {\n        continue\n      }\n\n      // tslint:disable-next-line:no-array-mutation\n      tasks.push(task)\n    }\n\n    return List(tasks)\n  }\n\n  public async findById(taskId: TaskId) {\n    const seriarized = localStorage.getItem(taskId.value)\n\n    if (seriarized === null) {\n      throw new Error // TODO:\n    }\n\n    return Task.deserialize(seriarized)\n  }\n\n  public async store(task: Task) {\n    return localStorage.setItem(task.id.value, task.serialize())\n  }\n\n  public async remove(task: Task) {\n    return localStorage.removeItem(task.id.value)\n  }\n}\n","import { Container } from 'inversify'\n\nimport ConfigRegistry from '~/config/ConfigRegistry'\nimport TaskRepository from '~/domain/repository/TaskRepository'\nimport EnvVarConfigRegistry from '~/infrastructure/EnvVarConfigRegistry'\nimport GetRepoImpl from '~/infrastructure/GetRepoImpl'\nimport TaskRepositoryFakeImpl from '~/infrastructure/persistence/double/TaskRepositoryFakeImpl' // TODO:\nimport Service from '~/redux'\nimport { ChessService } from '~/redux/modules/chess'\nimport { CounterService } from '~/redux/modules/counter'\nimport { IoService } from '~/redux/modules/io'\nimport LocaleSelectorService from '~/redux/modules/localeSelector'\nimport ReminderService from '~/redux/modules/reminder'\nimport UserAuthnService from '~/redux/modules/userAuthn'\nimport GetRepo from '~/useCase/GetRepo'\n\nconst container = new Container\n\ncontainer.bind<ConfigRegistry>('EnvVarConfig').to(EnvVarConfigRegistry)\ncontainer.bind<GetRepo>('GetRepo').to(GetRepoImpl)\ncontainer.bind<TaskRepository>('TaskRepository').to(TaskRepositoryFakeImpl)\ncontainer.bind(Service).toSelf()\ncontainer.bind(ChessService).toSelf()\ncontainer.bind(CounterService).toSelf()\ncontainer.bind(IoService).toSelf()\ncontainer.bind(LocaleSelectorService).toSelf()\ncontainer.bind(ReminderService).toSelf()\ncontainer.bind(UserAuthnService).toSelf()\n\nexport default container\n","import identity from '~/lib/identity'\n\nexport const isOneOf = <T extends readonly Json[]>(...options: T) => (input: unknown): input is T[number] => options.some((option) => option === input)\n\nexport const optional = <A extends unknown, T extends A>(isT: (input: A) => input is T) => (input: A | undefined): input is T | undefined => {\n  if (input === undefined) {\n    return true\n  }\n\n  return isT(input)\n}\n\nexport const isObject = <A extends B, T extends A, B = A>(isT: (input: B) => Record<keyof A, boolean>) => (input: A): input is T => {\n  return Object.values<boolean>(isT(input)).every(identity)\n}\n","import assert from 'assert'\n\nimport { isUrl } from '~/lib/guards/stringGuards'\nimport typed from '~/lib/typed'\nimport ValidationError from './ValidationError'\nimport { asString } from './commonValidators'\n\nexport const asBoundedLengthString = ({\n  lowerBound = -Infinity,\n  upperBound = Infinity,\n}: {\n  lowerBound?: number\n  upperBound?: number\n}) => (input: unknown) => {\n  assert(lowerBound <= upperBound)\n\n  const inputAsString = asString(input)\n\n  if (lowerBound <= inputAsString.length && inputAsString.length <= upperBound) {\n    return inputAsString\n  }\n\n  throw new ValidationError(\n    typed<[string, number, number]>`${ inputAsString } is not between ${ lowerBound } and ${ upperBound } characters.`,\n    'asBoundedLengthStringErrorMessage',\n    {\n      input: inputAsString.length,\n      lowerBound,\n      upperBound,\n    }\n  )\n}\n\nexport function asUrl(input: unknown): string.Url {\n  const inputAsString = asString(input)\n\n  if (!isUrl(inputAsString)) {\n    throw new ValidationError(typed<[string]>`${ inputAsString } is not a URL.`)\n  }\n\n  return inputAsString\n}\n","export function isUrl(input: string): input is string.Url {\n  try {\n    // tslint:disable-next-line:no-unused-expression\n    new URL(input)\n\n    return true\n  } catch (error: unknown) {\n    return false\n  }\n}\n"],"sourceRoot":""}