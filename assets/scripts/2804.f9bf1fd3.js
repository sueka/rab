(self.webpackChunkrap=self.webpackChunkrap||[]).push([[2804],{2804:function(e,t,n){"use strict";n.d(t,{nY:function(){return va},Wh:function(){return ya},cn:function(){return ma},nZ:function(){return _a},_8:function(){return wa},FV:function(){return Sa},sJ:function(){return ga}});var o=n(73935),r=n(67294);var a=function(e){return!!e&&"function"==typeof e.then};var s=function(e,t){if(null!=e)return e;throw new Error(null!=t?t:"Got unexpected null or undefined")};class i{}const u=new i,c={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(e){return e.state===this.state&&e.contents===this.contents},map(e){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const t=e(this.contents);return a(t)?f(t):l(t)}catch(t){return a(t)?f(t.next((()=>e(this.contents)))):d(t)}if("loading"===this.state)return f(this.contents.then(e).catch((t=>{if(a(t))return t.then((()=>e(this.contents)));throw t})));throw new Error("Invalid Loadable state")}};function l(e){return Object.freeze({state:"hasValue",contents:e,...c,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function d(e){return Object.freeze({state:"hasError",contents:e,...c,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function f(e){return Object.freeze({state:"loading",contents:e,...c,getValue(){throw this.contents.then((({__value:e})=>e))},toPromise(){return this.contents.then((({__value:e})=>e))},promiseMaybe(){return this.contents.then((({__value:e})=>e))},promiseOrThrow(){return this.contents.then((({__value:e})=>e))}})}var h={loadableWithValue:l,loadableWithError:d,loadableWithPromise:f,loadableLoading:function(){return f(new Promise((()=>{})))},loadableAll:function(e){return e.every((e=>"hasValue"===e.state))?l(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?d(s(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):f(Promise.all(e.map((e=>e.contents))).then((e=>({__value:e}))))},Canceled:i,CANCELED:u};var p=function(e,t,{error:n}={}){return null};var v={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var y=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};const m=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0);function _(e){var t;return null!==(t=m.get(e))&&void 0!==t&&t}_.setPass=e=>{m.set(e,!0)},_.setFail=e=>{m.set(e,!1)};var g=_;var S=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var w=function(e,...t){0};function b(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class T{constructor(e){b(this,"key",void 0),this.key=e}}class R extends T{}class A extends T{}var E={AbstractRecoilValue:T,RecoilState:R,RecoilValueReadOnly:A,isRecoilValue:function(e){return e instanceof R||e instanceof A}},N=E.AbstractRecoilValue,k=E.RecoilState,V=E.RecoilValueReadOnly,L=E.isRecoilValue,M=Object.freeze({__proto__:null,AbstractRecoilValue:N,RecoilState:k,RecoilValueReadOnly:V,isRecoilValue:L});class C{}const B=new C;class D extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const U=new Map,I=new Map;class x extends Error{}const z=new Map;function F(e){return z.get(e)}var O={nodes:U,recoilValues:I,registerNode:function(e){if(U.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}U.set(e.key,e);const t=null==e.set?new M.RecoilValueReadOnly(e.key):new M.RecoilState(e.key);return I.set(e.key,t),t},getNode:function(e){const t=U.get(e);if(null==t)throw new x(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return U.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!g("recoil_memory_managament_2020"))return;const n=U.get(e);var o;(null==n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(U.delete(e),null===(o=F(e))||void 0===o||o(),z.delete(e))},setConfigDeletionHandler:function(e,t){g("recoil_memory_managament_2020")&&(void 0===t?z.delete(e):z.set(e,t))},getConfigDeletionHandler:F,recoilValuesForKeys:function(e){return S(e,(e=>s(I.get(e))))},NodeMissingError:x,DefaultValue:C,DEFAULT_VALUE:B,RecoilValueNotReady:D};class P{}var $={RetentionZone:P,retentionZone:function(){return new P}};const{setByAddingToSet:W}=v,{getNode:q,getNodeMaybe:G,recoilValuesForKeys:j}=O,{RetentionZone:H}=$,K=Object.freeze(new Set);class Z extends Error{}function J(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=q(n),s=function(e,t,n){if(!g("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof H)r(n);else if(Array.isArray(n))for(const e of n)r(e);return()=>{if(!g("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof H)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function Y(e,t,n){return q(n).peek(e,t)}function Q(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let e=r.pop();e;e=r.pop()){var s;o.add(e);const t=null!==(s=a.nodeToNodeSubscriptions.get(e))&&void 0!==s?s:K;for(const e of t)o.has(e)||r.push(e)}return o}var X={getNodeLoadable:function(e,t,n){return J(e,t,n,"get"),q(n).get(e,t)},peekNodeLoadable:Y,setNodeValue:function(e,t,n,o){const r=q(n);if(null==r.set)throw new Z(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return J(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=G(t);return null==r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:W(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const s=e.getState(),i=e.getGraph(t.version),u=s.knownAtoms.has(n)?"atom":s.knownSelectors.has(n)?"selector":void 0,c=y(Q(e,t,new Set([n])),(e=>e!==n));return{loadable:Y(e,t,n),isActive:s.knownAtoms.has(n)||s.knownSelectors.has(n),isSet:"selector"!==u&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:u,deps:j(null!==(o=i.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:j(c),components:S(null!==(r=null===(a=s.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}},getDownstreamNodes:Q,initializeNodeIfNewToStore:J};const{CANCELED:ee}=h,{getDownstreamNodes:te,getNodeLoadable:ne,setNodeValue:oe}=X,{getNodeMaybe:re}=O,{DefaultValue:ae,RecoilValueNotReady:se}=O,{AbstractRecoilValue:ie,RecoilState:ue,RecoilValueReadOnly:ce,isRecoilValue:le}=M;function de(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"==typeof o){const r=ne(e,t,n);if("loading"===r.state)throw new se(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=oe(e,t,o.key,a);for(const[e,n]of s.entries())fe(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;fe(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=re(e);null==a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else p(`Unknown action ${n.type}`)}function fe(e,t,n){"hasValue"===n.state&&n.contents instanceof ae?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function he(e,t){e.replaceState((n=>{const o=function(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}(n);for(const n of t)de(e,o,n);return ye(e,o),o}))}function pe(e,t){if(ve.length){const n=ve[ve.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else he(e,[t])}const ve=[];function ye(e,t){const n=te(e,t,t.dirtyAtoms);for(const e of n){var o,r;null===(o=re(e))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function me(e,t,n){pe(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let _e=0;var ge={RecoilValueReadOnly:ce,AbstractRecoilValue:ie,RecoilState:ue,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&p("Tried to read from a discarded tree");const s=ne(e,n,t);return"loading"===s.state&&s.contents.catch((()=>ee)),s},setRecoilValue:me,setRecoilValueLoadable:function(e,t,n){if(n instanceof ae)return me(e,t,n);pe(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){pe(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){pe(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=_e++,a=e.getState();return a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),s(a.nodeToComponentSubscriptions.get(t)).set(r,[null!=o?o:"<not captured>",n]),{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):p(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:le,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof ae?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return ve.push(e),()=>{for(const[t,n]of e)he(t,n);ve.pop()!==e&&p("Incorrect order of batch popping")}},invalidateDownstreams_FOR_TESTING:ye};const{unstable_batchedUpdates:Se}=o;var we={unstable_batchedUpdates:Se};const{unstable_batchedUpdates:be}=we;var Te={unstable_batchedUpdates:be};const{batchStart:Re}=ge,{unstable_batchedUpdates:Ae}=Te;let Ee=Ae;var Ne={getBatcher:()=>Ee,setBatcher:e=>{Ee=e},batchUpdates:e=>{Ee((()=>{let t=()=>{};try{t=Re(),e()}finally{t()}}))}};var ke={enqueueExecution:function(e,t){t()}};var Ve=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var Le=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function Me(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:Ve(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);s(r.get(e)).add(t)})),a){Ve(a,e).forEach((e=>{if(!r.has(e))return;const n=s(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var Ce={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),s(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:Le(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:Le(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=s(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&p("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(Me(e,u),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){Me(e,t.getGraph(i.currentTree.version),u)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var c;const n=null===(c=i.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){Me(e,t.getGraph(n),u)}}}};var Be,De=(function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},u=function(e){return function(){return e}},c=n.hash=function(e){var n=void 0===e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:T}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},w=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),u=l(n,a);return g(t,d(i)|d(u),i===u?[e(t,n+5,o,r,a,s)]:i<u?[r,s]:[s,r])},b=function(e,t){return e===t.edit},T=function(e,t,n,o,r,a,s){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===i?(--s.value,v):b(e,this)?(this.value=u,this):m(e,r,a,u)}var c=o();return c===i?this:(++s.value,w(e,n,this.hash,this,r,m(e,r,a,c)))},R=function(e,t,n,o,r,a,s){if(r===this.hash){var u=function(e,t,n,o,r,a,s,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--u.value,p(e,l,r)):h(e,l,m(t,o,s,v),r)}}var y=a();return y===i?r:(++u.value,h(e,c,m(t,o,s,y),r))}(b(e,this),e,t,this.hash,this.children,o,a,s);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===i?this:(++s.value,w(e,n,this.hash,this,r,m(e,r,a,c)))},A=function(e,t,n,o,r,s,i){var u=this.mask,c=this.children,m=l(n,r),_=d(m),w=f(u,_),T=u&_,R=T?c[w]:v,A=R._modify(e,t,n+5,o,r,s,i);if(R===A)return this;var E,N=b(e,this),k=u,V=void 0;if(T&&y(A)){if(!(k&=~_))return v;if(c.length<=2&&((E=c[1^w])===v||1===E.type||2===E.type))return c[1^w];V=p(N,w,c)}else if(T||y(A))V=h(N,w,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,u=0;s;++u)1&s&&(a[u]=r[i++]),s>>>=1;return a[t]=n,S(e,i+1,a)}(e,m,A,u,c);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,u=new Array(r+1);s<t;)u[i++]=o[s++];for(u[t]=n;s<r;)u[++i]=o[s++];return u}(N,w,A,c)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,i){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var m=b(e,this),_=void 0;if(y(f)&&!y(p))++u,_=h(m,d,p,c);else if(!y(f)&&y(p)){if(--u<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,u=o.length;i<u;++i)if(i!==n){var c=o[i];c&&!y(c)&&(r[a++]=c,s|=1<<i)}return g(e,s,r)}(e,u,d,c);_=h(m,d,v,c)}else _=h(m,d,p,c);return m?(this.size=u,this.children=_,this):S(e,u,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var u=o();return u===i?v:(++s.value,m(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,u=0,c=i.length;u<c;++u){var h=i[u];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(i,e,t,n)!==i};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var B=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||B,hash:e&&e.hash||c},v,0)},n.empty=n.make();var D=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return D(this)};var U=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return U(n,e,t,this)};var I=n.modify=function(e,t,n){return U(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return I(t,e,this)};var x=n.setHash=function(e,t,n,o){return U(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return x(e,t,n,this)};var z=n.set=function(e,t,n){return x(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return z(e,t,this)};var F=u(i),O=n.removeHash=function(e,t,n){return U(F,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return O(e,t,this)};var P=n.remove=function(e,t){return O(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return P(e,this)};var $=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return $(this)};var W=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return W(this)};var q=n.mutate=function(e,t){var n=$(t);return e(n),W(n)};N.prototype.mutate=function(e){return q(e,this)};var G=function(e){return e&&j(e[0],e[1],e[2],e[3],e[4])},j=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return H(a,o,[e,t,n,o,r])}return G(r)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return j(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(H(e._root,t))},Y=function(e){return[e.key,e.value]},Q=n.entries=function(e){return J(e,Y)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return Q(this)};var X=function(e){return e.key},ee=n.keys=function(e){return J(e,X)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var u=a[s++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}(Be={exports:{}},Be.exports),Be.exports);class Ue{constructor(e){b(this,"_map",void 0),this._map=new Map(null==e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return xe(this)}toMap(){return new Map(this._map)}}class Ie{constructor(e){if(b(this,"_hamt",De.empty.beginMutation()),e instanceof Ie){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return xe(this)}toMap(){return new Map(this._hamt)}}function xe(e){return g("recoil_hamt_2020")?new Ie(e):new Ue(e)}var ze=xe,Fe=Object.freeze({__proto__:null,persistentMap:ze});const{graph:Oe}=Ce,{persistentMap:Pe}=Fe;let $e=0;const We=()=>$e++;function qe(){const e=We();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Pe(),nonvalidatedAtoms:Pe()}}var Ge={makeEmptyTreeState:qe,makeEmptyStoreState:function(){const e=qe();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,Oe()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:We};var je=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var He=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:Ke}=X,{deleteNodeConfigIfPossible:Ze,getNode:Je}=O,{RetentionZone:Ye}=$,Qe=new Set;function Xe(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void p("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const e of t)if(e instanceof Ye)for(const t of tt(n,e))r.add(t);else r.add(e);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return u(t),a;function u(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),i=[],u=new Set;for(;n.size>0;)c(s(n.values().next().value));return i;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(u.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const e of t)c(e);u.add(e),n.delete(e),i.push(e)}}(e,o,t,a,i);for(const e of l){var d;if("recoilRoot"===Je(e).retainedBy){i.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){i.add(e);continue}if(nt(e).some((e=>n.retention.referenceCounts.get(e)))){i.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&He(t,(e=>i.has(e)))?i.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:Qe){var h;a.has(t)||f.add(t)}f.size&&u(f)}}(e,r);for(const t of a)et(e,o,t)}function et(e,t,n){if(!g("recoil_memory_managament_2020"))return;Ke(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=nt(n);for(const e of r){var a;null===(a=o.retention.nodesRetainedByZone.get(e))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Ze(n)}function tt(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:Qe}function nt(e){const t=Je(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof Ye?[t]:t}function ot(e,t){if(!g("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Xe(e,new Set([t]))}(e,t)}var rt={updateRetainCount:function(e,t,n){var o;if(!g("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?ot(e,t):r.set(t,a)},updateRetainCountToZero:ot,releaseScheduledRetainablesNow:function(e){if(!g("recoil_memory_managament_2020"))return;const t=e.getState();Xe(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var at=function*(e){for(const t of e)for(const e of t)yield e};var st={isSSR:"undefined"==typeof window,isReactNative:"undefined"!=typeof navigator&&"ReactNative"===navigator.product};const{isSSR:it}=st,{batchUpdates:ut}=Ne,{initializeNodeIfNewToStore:ct,peekNodeInfo:lt}=X,{graph:dt}=Ce,{DEFAULT_VALUE:ft,recoilValues:ht,recoilValuesForKeys:pt}=O,{AbstractRecoilValue:vt,getRecoilValueAsLoadable:yt,setRecoilValue:mt,setUnvalidatedRecoilValue:_t}=ge,{updateRetainCount:gt,updateRetainCountToZero:St}=rt,{getNextTreeStateVersion:wt,makeEmptyStoreState:bt}=Ge;class Tt{constructor(e){b(this,"_store",void 0),b(this,"_refCount",0),b(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),yt(this._store,e)))),b(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),b(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null==e?void 0:e.isModified)){if(!1===(null==e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return pt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null==e?void 0:e.isInitialized)?ht.values():!0===e.isInitialized?pt(at([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):y(ht.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),b(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),lt(this._store,this._store.getState().currentTree,e)))),b(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new Et(this);return e(t),At(t.getStore_INTERNAL())})),b(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new Et(this);return await e(t),At(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return s(n.get(t));const o=dt();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())ct(this._store,e.currentTree,t,"get"),gt(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!g("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){g("recoil_memory_managament_2020")&&(it||window.setTimeout((()=>this.release_INTERNAL()),0))}release_INTERNAL(){g("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){g("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Rt(e,t,n=!1){const o=e.getState(),r=n?wt():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function At(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:s(n.previousTree);return new Tt(Rt(e,o))}class Et extends Tt{constructor(e){super(Rt(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),b(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();ut((()=>{gt(n,e.key,1),mt(this.getStore_INTERNAL(),e,t)}))})),b(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();ut((()=>{gt(t,e.key,1),mt(this.getStore_INTERNAL(),e,ft)}))})),b(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();ut((()=>{for(const[n,o]of e.entries())gt(t,n,1),_t(t,new vt(n),o)}))}))}}var Nt={Snapshot:Tt,MutableSnapshot:Et,freshSnapshot:function(e){const t=new Tt(bt());return null!=e?t.map(e):t},cloneSnapshot:At},kt=Nt.Snapshot,Vt=Nt.MutableSnapshot,Lt=Nt.freshSnapshot,Mt=Nt.cloneSnapshot,Ct=Object.freeze({__proto__:null,Snapshot:kt,MutableSnapshot:Vt,freshSnapshot:Lt,cloneSnapshot:Mt});const{getNextTreeStateVersion:Bt,makeEmptyStoreState:Dt}=Ge,{cleanUpNode:Ut,getDownstreamNodes:It,setNodeValue:xt,setUnvalidatedAtomValue_DEPRECATED:zt}=X,{graph:Ft}=Ce,{cloneGraph:Ot}=Ce,{applyAtomValueWrites:Pt}=ge,{releaseScheduledRetainablesNow:$t}=rt,{freshSnapshot:Wt}=Ct,{useCallback:qt,useContext:Gt,useEffect:jt,useMemo:Ht,useRef:Kt,useState:Zt}=r;function Jt(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const Yt=Object.freeze({getState:Jt,replaceState:Jt,getGraph:Jt,subscribeToTransactions:Jt,addTransactionMetadata:Jt});let Qt=!1;function Xt(e){if(Qt)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){g("recoil_memory_managament_2020")&&g("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&$t(e);const n=t.currentTree.version,o=Bt();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ot(s(t.graphsByVersion.get(n))))}}const en=r.createContext({current:Yt}),tn=()=>Gt(en),nn=r.createContext(null);function on(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,n]of r)n(e);for(const[n,o]of t.transactionSubscriptions)o(e);const r=It(e,n,o);for(const e of r){const o=t.nodeToComponentSubscriptions.get(e);if(o)for(const[e,[t,r]]of o)r(n)}t.suspendedComponentResolvers.forEach((e=>e()))}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function rn({setNotifyBatcherOfChange:e}){const t=tn(),[n,o]=Zt([]);return e((()=>o({}))),jt((()=>{ke.enqueueExecution("Batcher",(()=>{const e=t.current.getState();e.commitDepth++;try{const{nextTree:n}=e;if(null===n)return;e.previousTree=e.currentTree,e.currentTree=n,e.nextTree=null,on(t.current);const o=s(e.previousTree).version;e.graphsByVersion.delete(o),e.previousTree=null,g("recoil_memory_managament_2020")&&$t(t.current)}finally{e.commitDepth--}}))})),jt((()=>()=>{e((()=>{}))}),[e]),null}let an=0;function sn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var a;let i;const u=Kt(null),c=qt((e=>{u.current=e}),[u]),l=null!==(a=r.createMutableSource)&&void 0!==a?a:r.unstable_createMutableSource,d=null!=n?n:{getState:()=>i.current,replaceState:e=>{const t=f.current.getState();Xt(f.current);const n=s(t.nextTree);let o;try{Qt=!0,o=e(n)}finally{Qt=!1}o!==n&&(t.nextTree=o,s(u.current)())},getGraph:e=>{const t=i.current.graphsByVersion;if(t.has(e))return s(t.get(e));const n=Ft();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=an++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=an++;return s(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{Xt(f.current);for(const t of Object.keys(e))s(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=Kt(d);i=Kt(null!=e?function(e,t){const n=Dt();return t({set:(t,o)=>{const r=n.currentTree,a=xt(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:je(r.dirtyAtoms,s),atomValues:Pt(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=zt(n.currentTree,t,e)}))}}),n}(d,e):null!=t?function(e){return Wt().map(e).getStore_INTERNAL().getState()}(t):Dt());const h=Ht((()=>l?l(i,(()=>i.current.currentTree.version)):null),[l,i]);return jt((()=>()=>{for(const e of f.current.getState().knownAtoms)Ut(f.current,e)}),[]),r.createElement(en.Provider,{value:f},r.createElement(nn.Provider,{value:h},r.createElement(rn,{setNotifyBatcherOfChange:c}),o))}var un={useStoreRef:tn,useRecoilMutableSource:function(){const e=Gt(nn);return null==e&&w("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,o=tn();return!1===t&&o.current!==Yt?r.createElement(r.Fragment,null,e.children):r.createElement(sn,n)},sendEndOfBatchNotifications_FOR_TESTING:on};var cn=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var ln=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var dn=function(e,t){if(!e)throw new Error(t)};var fn,hn=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const pn=null!==(fn=r.useMutableSource)&&void 0!==fn?fn:r.unstable_useMutableSource;var vn={mutableSourceExists:function(){return pn&&!("undefined"!=typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:pn};var yn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useRef:mn}=r;var _n=function(){return mn(),"<component name not available>"};const{batchUpdates:gn}=Ne,{DEFAULT_VALUE:Sn,getNode:wn,nodes:bn}=O,{useRecoilMutableSource:Tn,useStoreRef:Rn}=un,{isRecoilValue:An}=M,{AbstractRecoilValue:En,getRecoilValueAsLoadable:Nn,setRecoilValue:kn,setRecoilValueLoadable:Vn,setUnvalidatedRecoilValue:Ln,subscribeToRecoilValue:Mn}=ge,{updateRetainCount:Cn}=rt,{RetentionZone:Bn}=$,{Snapshot:Dn,cloneSnapshot:Un}=Ct,{setByAddingToSet:In}=v,{isSSR:xn}=st,{mutableSourceExists:zn,useMutableSource:Fn}=vn,{useCallback:On,useEffect:Pn,useMemo:$n,useRef:Wn,useState:qn}=r,Gn=12e4;function jn(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function Hn(e){return g("recoil_memory_managament_2020")&&no(e),zn()?function(e){const t=Rn(),n=On((()=>{const n=t.current,o=n.getState().currentTree;return Nn(n,e,o)}),[t,e]),o=On((()=>n()),[n]),r=_n(),a=On(((o,a)=>{const s=t.current;return Mn(s,e,(()=>{if(!g("recoil_suppress_rerender_in_callback"))return a();const e=n();u.current.is(e)||a(),u.current=e}),r).release}),[t,e,r,n]),s=Tn(),i=Fn(s,o,a),u=Wn(i);return Pn((()=>{u.current=i})),i}(e):function(e){const t=Rn(),[n,o]=qn([]),r=_n();Pn((()=>{const n=t.current,a=n.getState(),i=Mn(n,e,(t=>{var r;if(!g("recoil_suppress_rerender_in_callback"))return o([]);const a=Nn(n,e,n.getState().currentTree);(null===(r=s.current)||void 0===r?void 0:r.is(a))||o(a),s.current=a}),r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,o([])}));else{var u;if(!g("recoil_suppress_rerender_in_callback"))return o([]);const t=Nn(n,e,n.getState().currentTree);(null===(u=s.current)||void 0===u?void 0:u.is(t))||o(t),s.current=t}return i.release}),[r,e,t]);const a=Nn(t.current,e),s=Wn(a);return Pn((()=>{s.current=a})),a}(e)}function Kn(e){const t=Rn();return jn(Hn(e),e,t)}function Zn(e){const t=Rn();return On((n=>{kn(t.current,e,n)}),[t,e])}function Jn(e){const t=Rn();Pn((()=>t.current.subscribeToTransactions(e).release),[e,t])}function Yn(e){const t=e.atomValues.toMap(),n=Le(cn(t,((e,t)=>{const n=wn(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return hn(e.nonvalidatedAtoms.toMap(),n)}function Qn(e){const t=Wn();return Pn((()=>{t.current=e})),t.current}function Xn(){const e=Rn();return On((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;gn((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,i;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(i=a.atomValues.get(t))||void 0===i?void 0:i.contents)&&wn(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{Vn(e.current,new En(t),a.atomValues.has(t)?s(a.atomValues.get(t)):Sn)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])}class eo{}const to=new eo;function no(e){if(g("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Bn?e:e.key)),n=Rn();Pn((()=>{if(!g("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!xn)window.clearTimeout(o.current),o.current=null;else{p("Did not retain recoil value on render, or committed after timeout elapsed. This is fine, but odd.");for(const n of t)Cn(e,n,1)}return()=>{for(const n of t)Cn(e,n,-1)}}),[n,...t]);const o=Wn(),r=Qn(t);if(!(xn||void 0!==r&&yn(r,t))){const e=n.current;for(const n of t)Cn(e,n,1);if(r)for(const t of r)Cn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)Cn(e,n,-1)}),Gn)}}(e)}var oo={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:Xn,useRecoilCallback:function(e,t){const n=Rn(),o=Xn();return On(((...t)=>{function r(e,t){kn(n.current,e,t)}function a(e){kn(n.current,e,Sn)}const s=Un(n.current);let i=to;return gn((()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof e)throw new Error(n);const u=e({set:r,reset:a,snapshot:s,gotoSnapshot:o});if("function"!=typeof u)throw new Error(n);i=u(...t)})),i instanceof eo&&dn(!1),i}),null!=t?[...t,n]:void 0)},useRecoilInterface:function(){const e=Rn(),[t,n]=qn([]),o=Wn(new Set);o.current=new Set;const r=Wn(new Set),a=Wn(new Map),s=On((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),i=_n();return Pn((()=>{const t=e.current;function u(e,t){a.current.has(t)&&n([])}Ve(o.current,r.current).forEach((e=>{if(a.current.has(e))return void w(`Double subscription to RecoilValue "${e}"`);const n=Mn(t,new En(e),(t=>{u(0,e)}),i);a.current.set(e,n);t.getState().nextTree?t.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{u(t.getState(),e)})):u(t.getState(),e)})),Ve(r.current,o.current).forEach((e=>{s(e)})),r.current=o.current})),Pn((()=>{const e=a.current;return()=>e.forEach(((e,t)=>s(t)))}),[s]),$n((()=>{function t(t){return n=>{kn(e.current,t,n)}}function n(t){return o.current.has(t.key)||(o.current=In(o.current,t.key)),Nn(e.current,t)}function r(t){return jn(n(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[n(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>kn(e.current,t,Sn)}}}),[o,e])},useRecoilSnapshot:function(){const e=Rn(),[t,n]=qn((()=>Un(e.current))),o=Qn(t),r=Wn();return Pn((()=>(r.current&&!xn&&window.clearTimeout(r.current),t.retain())),[t]),Jn(On((e=>n(Un(e))),[])),o===t||xn||(r.current&&(null==o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout((()=>{t.release_INTERNAL(),r.current=null}),Gn)),t},useRecoilState:function(e){return[Kn(e),Zn(e)]},useRecoilStateLoadable:function(e){return[Hn(e),Zn(e)]},useRecoilTransactionObserver:function(e){Jn(On((t=>{const n=Un(t,"current"),o=Un(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useRecoilValue:Kn,useRecoilValueLoadable:Hn,useRetain:no,useResetRecoilState:function(e){const t=Rn();return On((()=>{kn(t.current,e,Sn)}),[t,e])},useSetRecoilState:Zn,useSetUnvalidatedAtomValues:function(){const e=Rn();return(t,n={})=>{gn((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>Ln(e.current,new En(n),t)))}))}},useTransactionObservation_DEPRECATED:function(e){Jn(On((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(p("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=Yn(o),a=Yn(n),s=Le(bn,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=ln(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:Jn};const{peekNodeInfo:ro}=X,{useStoreRef:ao}=un;var so=function(){const e=ao();return({key:t})=>ro(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:io,useStoreRef:uo}=un,{useMemo:co}=r;var lo=function(){const e=uo().current;return co((()=>function({children:t}){return r.createElement(io,{store_INTERNAL:e},t)}),[e])};const{isReactNative:fo,isSSR:ho}=st;function po(e,t,n){if("string"==typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null==t?void 0:t.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!=typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(a(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>po(e,t,n.toString())))}]`;if("function"==typeof e.toJSON)return po(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"==typeof n?n:po(n,t)]=r;return po(o,t,n)}return e instanceof Set?po(Array.from(e).sort(((e,n)=>po(e,t).localeCompare(po(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"==typeof e[Symbol.iterator]?po(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${po(n,t)}:${po(e[n],t,n)}`)).join(",")}}`}var vo=function(e,t={allowFunctions:!1}){return po(e,t)};const yo=(e,t,n)=>{var o;if(null==e)return;if(null==n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return yo(e.branches.get(r),t,n)},mo=(e,t,n,o,r,a)=>{var s;let i;if(null==e)if(0===t.length)i={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...s]=t,[u,c]=e;i={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},i.branches.set(c,mo(null,s,i,o,c,a))}else if(i=e,t.length){const[n,...r]=t,[s,i]=n;("branch"!==e.type||e.nodeKey!==s)&&dn(!1),e.branches.set(i,mo(e.branches.get(i),r,e,o,i,a))}return null==a||null===(s=a.onNodeVisit)||void 0===s||s.call(a,i),i},_o=(e,t,n)=>n?(n.branches.delete(t.branchKey),go(e,n,n.parent)):e===t,go=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),go(e,n,n.parent)):e===t,So=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+So(t)),0);var wo=class{constructor(e){var t,n,o;b(this,"_numLeafs",void 0),b(this,"_root",void 0),b(this,"_onHit",void 0),b(this,"_onSet",void 0),b(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null==e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null==e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null==e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return yo(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null==t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o;const r=mo(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null==n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}});this.root()||(this._root=r),this._numLeafs++,this._onSet(s(o))}delete(e){if(!this.root())return!1;const t=s(this.root());return!!_o(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=So(e),!0))}clear(){this._numLeafs=0,this._root=null}},bo=Object.freeze({__proto__:null,TreeCache:wo});var To=class{constructor(e){var t;b(this,"_maxSize",void 0),b(this,"_size",void 0),b(this,"_head",void 0),b(this,"_tail",void 0),b(this,"_map",void 0),b(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=s(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Ro=Object.freeze({__proto__:null,LRUCache:To});const{LRUCache:Ao}=Ro,{TreeCache:Eo}=bo;var No=function(e,t=(e=>e)){const n=new Ao({maxSize:e}),o=new Eo({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:ko}=bo,Vo={equality:"reference",eviction:"none",maxSize:1/0};var Lo=function({equality:e=Vo.equality,eviction:t=Vo.eviction,maxSize:n=Vo.maxSize}=Vo){return function(e,t,n){switch(e){case"none":return new ko({mapNodeValue:n});case"lru":return No(s(t),n)}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>vo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};var Mo={startPerfBlock:function(e){return()=>null}};const{CANCELED:Co,Canceled:Bo,loadableWithError:Do,loadableWithPromise:Uo,loadableWithValue:Io}=h,{getNodeLoadable:xo,peekNodeLoadable:zo,setNodeValue:Fo}=X,{saveDependencyMapToStore:Oo}=Ce,{DEFAULT_VALUE:Po,RecoilValueNotReady:$o,getConfigDeletionHandler:Wo,registerNode:qo}=O,{isRecoilValue:Go}=M,{AbstractRecoilValue:jo}=M,{setRecoilValueLoadable:Ho}=ge,{retainedByOptionWithDefault:Ko}=rt,{cloneSnapshot:Zo}=Ct,{startPerfBlock:Jo}=Mo,Yo=[],Qo=new Map,Xo=(()=>{let e=0;return()=>e++})();var er=function(e){const{key:t,get:n,cachePolicy_UNSTABLE:o}=e,r=null!=e.set?e.set:void 0,i=Lo(null!=o?o:{equality:"reference",eviction:"none"}),u=Ko(e.retainedBy_UNSTABLE),c=new Map;let l=0;function d(){return!g("recoil_memory_managament_2020")||l>0}function f(e){return c.has(e)||c.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),s(c.get(e))}function h(e){return l++,e.getState().knownSelectors.add(t),()=>{l--,e.getState().knownSelectors.delete(t),c.delete(e)}}function v(){return void 0!==Wo(t)&&!d()}function y(e,t,n){if("loading"===t.state){let t=Qo.get(n);null==t&&Qo.set(n,t=new Set),t.add(e)}}function m(e,t,n){if(t.atomValues.has(n))return s(t.atomValues.get(n));const o=xo(e,t,n),r=e.getState().knownSelectors.has(n);return"loading"!==o.state&&r&&t.atomValues.set(n,o),o}function _(e,n,o,r,a){return n.then((n=>{if(!d())return V(e,a),Co;if(n instanceof Bo)return p("Selector was released while it had dependencies"),Co;const{__key:r,__value:s}=null!=n?n:{};let i=!0;null!=r&&(o.atomValues.set(r,Io(s)),i=!1);const[u,c]=b(e,o,a,i);if(L(e,a)&&k(c,e,a),M(u),"loading"!==u.state&&(B(o,T(c),u),w(e,o,new Set(c.keys()),a),S(e,u,a)),"hasError"===u.state)throw u.contents;return"hasValue"===u.state?{__value:u.contents,__key:t}:u.contents})).catch((t=>{if(!d())return V(e,a),Co;const n=Do(t);throw C(t),B(o,T(r),Do(t)),w(e,o,new Set(r.keys()),a),S(e,n,a),t}))}function S(e,n,o){L(e,o)&&(N(n,e),function(e,n){const o=Qo.get(n);if(void 0!==o){for(const n of o)Ho(n,new jo(t),e);Qo.delete(n)}}(n,o))}function w(e,n,o,r){var a,s,i,u,c,l,d;(L(e,r)||n.version===(null===(a=e.getState())||void 0===a||null===(s=a.currentTree)||void 0===s?void 0:s.version)||n.version===(null===(i=e.getState())||void 0===i||null===(u=i.nextTree)||void 0===u?void 0:u.version))&&Oo(new Map([[t,o]]),e,null!==(c=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==c?c:e.getState().currentTree.version)}function b(e,o,r,s=!1){const i=Jo(t);let u,c,l=!1;const f=new Map,h=new Set;function p(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),w(e,t,n,r)}(e,o,h,n,r);const a=s?xo(e,o,n):m(e,o,n);if(M(a),f.set(n,a),"hasValue"===a.state)return a.contents;throw a.contents}w(e,o,h,r);let v=!1;const y=t=>(...n)=>{if(!v)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=Zo(e),r=t({snapshot:o});if("function"!=typeof r)throw new Error("getCallback() expects a function that returns a function.");return r(...n)};try{u=n({get:p,getCallback:y}),u=Go(u)?p(u):u,v=!0,a(u)?u=function(e,n,o,r,s){return n.then((n=>{if(!d())return V(e,s),Co;const a=Io(n);return C(n),B(o,T(r),a),w(e,o,new Set(r.keys()),s),S(e,a,s),{__value:n,__key:t}})).catch((t=>{if(!d())return V(e,s),Co;if(L(e,s)&&k(r,e,s),a(t))return _(e,t,o,r,s);const n=Do(t);throw C(t),B(o,T(r),n),w(e,o,new Set(r.keys()),s),S(e,n,s),t}))}(e,u,o,f,r).finally(i):i()}catch(t){u=t,a(u)?u=_(e,u,o,f,r).finally(i):(l=!0,i())}return c=l?Do(u):a(u)?Uo(u):Io(u),M(c),[c,f]}function T(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function R(e,t){const n=Xo(),[o,r]=b(e,t,n);return N(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&B(e,t,n)}(t,T(r),o),y(e,o,n),o}function A(e,n){const o=function(e,n){const o=new Set,r=f(e),a=i.get((t=>("string"!=typeof t&&dn(!1),m(e,n,t).contents)),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==t&&"string"==typeof e.nodeKey&&o.add(e.nodeKey)}});return a&&w(e,n,o,r.latestExecutionId),a}(e,n);if(null!=o)return N(o,e),o;const r=function(e,t){var n;const[,o]=null!==(n=Array.from(c.entries()).find((([,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=f(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=E.get(t.version))&&void 0!==o?o:new Map).entries()),i=E.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===r.stateVersion||i)return!1;return E.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>{const r=m(e,t,n);return r.contents!==o.contents&&!("loading"===o.state&&"loading"!==r.state)}))}(e,t))))&&void 0!==n?n:[];return o}(e,n);if(r){const t=r;return y(e,s(t.latestLoadable),s(t.latestExecutionId)),s(t.latestLoadable)}return R(e,n)}const E=new Map;function N(e,t,n,o,r){const a=f(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null==r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function k(e,t,n){const o=f(t);L(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function V(e,t){L(e,t)&&c.delete(e)}function L(e,t){return t===f(e).latestExecutionId}function M(e){"loading"!==e.state&&C(e.contents)}function C(e){0}function B(e,n,o){e.atomValues.set(t,o),i.set(n,o)}function D(e,t){return i.get((n=>{"string"!=typeof n&&dn(!1);const o=zo(e,t,n);return null==o?void 0:o.contents}))}function U(e,n){return function(e){if(Yo.includes(t)){const e=`Recoil selector has circular dependencies: ${Yo.slice(Yo.indexOf(t)).join(" → ")}`;return Do(new Error(e))}Yo.push(t);try{return e()}finally{Yo.pop()}}((()=>A(e,n)))}function I(e){e.atomValues.delete(t)}if(null!=r){return qo({key:t,peek:D,get:U,set:(e,t,n)=>{let o=!1;const s=new Map;function i({key:n}){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const r=m(e,t,n);if(M(r),"hasValue"===r.state)return r.contents;throw"loading"===r.state?new $o(n):r.contents}function u(n,r){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const a="function"==typeof r?r(i(n)):r;Fo(e,t,n.key,a).forEach(((e,t)=>s.set(t,e)))}const c=r({set:u,get:i,reset:function(e){u(e,Po)}},n);if(void 0!==c)throw a(c)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return o=!0,s},init:h,invalidate:I,shouldDeleteConfigOnRelease:v,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}return qo({key:t,peek:D,get:U,init:h,invalidate:I,shouldDeleteConfigOnRelease:v,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})};const{loadableWithError:tr,loadableWithPromise:nr,loadableWithValue:or}=h,{DEFAULT_VALUE:rr,DefaultValue:ar,getConfigDeletionHandler:sr,registerNode:ir,setConfigDeletionHandler:ur}=O,{isRecoilValue:cr}=M,{markRecoilValueModified:lr,setRecoilValue:dr,setRecoilValueLoadable:fr}=ge,{retainedByOptionWithDefault:hr}=rt;function pr(e){const{key:t,persistence_UNSTABLE:n}=e,o=hr(e.retainedBy_UNSTABLE);let r,i=0,u=a(e.default)?nr(e.default.then((e=>{u=or(e);return{__key:t,__value:e}})).catch((e=>{throw u=tr(e),e}))):or(e.default);const c=new Map;const l=ir({key:t,peek:function(e,n){var o,a,s;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:null===(s=r)||void 0===s?void 0:s[1])&&void 0!==o?o:u},get:function(e,o){if(o.atomValues.has(t))return s(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return w(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),u;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,rr),s=a instanceof ar?u:or(a);return r=s,r}return u},set:function(e,n,o){if(n.atomValues.has(t)){const e=s(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof ar)return new Map;return r=void 0,(new Map).set(t,or(o))},init:function(n,o,r){i++;const s=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===u.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||lr(n,l)};u.contents.then(e).catch(e)}let d=rr,f=null;if(null!=e.effects_UNSTABLE&&!s){let o=!0;const s=e=>t=>{if(o){const n=d instanceof ar||a(d)?"hasValue"===u.state?u.contents:rr:d;d="function"==typeof t?t(n):t,a(d)&&(d=d.then((t=>(f={effect:e,value:t},t))))}else{if(a(t))throw new Error("Setting atoms to async values is not implemented.");"function"!=typeof t&&(f={effect:e,value:t}),dr(n,l,"function"==typeof t?n=>{const o=t(n);return f={effect:e,value:o},o}:t)}},i=e=>()=>s(e)(rr),v=e=>o=>{n.subscribeToTransactions((n=>{let{currentTree:r,previousTree:a}=n.getState();a||(p("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),a=r);const s=r.atomValues.get(t);if(null==s||"hasValue"===s.state){var i,c,l,d;const n=null!=s?s.contents:rr,r=null!==(i=a.atomValues.get(t))&&void 0!==i?i:u,h="hasValue"===r.state?r.contents:rr;(null===(c=f)||void 0===c?void 0:c.effect)!==e||(null===(l=f)||void 0===l?void 0:l.value)!==n?o(n,h):(null===(d=f)||void 0===d?void 0:d.effect)===e&&(f=null)}}),t)};for(const t of null!==(h=e.effects_UNSTABLE)&&void 0!==h?h:[]){var h;const e=t({node:l,trigger:r,setSelf:s(t),resetSelf:i(t),onSet:v(t)});null!=e&&c.set(n,e)}o=!1}if(!(d instanceof ar)){var v;const e=a(d)?nr(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&dr(e,l,n),{__key:t,__value:n}})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&fr(e,l,tr(n)),n}));return o}(n,d)):or(d);o.atomValues.set(t,e),null===(v=n.getState().nextTree)||void 0===v||v.atomValues.set(t,e)}return()=>{var e;i--,null===(e=c.get(n))||void 0===e||e(),c.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==sr(t)&&i<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return l}function vr(e){const{default:t,...n}=e;return cr(t)?function(e){const t=vr({...e,default:rr,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof ar?t:s(e.persistence_UNSTABLE).validator(t,rr)},effects_UNSTABLE:e.effects_UNSTABLE}),n=er({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof ar?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return ur(n.key,sr(e.key)),n}({...n,default:t}):pr({...n,default:t})}var yr=vr;var mr=class{constructor(e){var t;b(this,"_map",void 0),b(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null==e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},_r=Object.freeze({__proto__:null,MapCache:mr});const{LRUCache:gr}=Ro,{MapCache:Sr}=_r,wr={equality:"reference",eviction:"none",maxSize:1/0};var br=function({equality:e=wr.equality,eviction:t=wr.eviction,maxSize:n=wr.maxSize}=wr){return function(e,t,n){switch(e){case"none":return new Sr({mapKey:n});case"lru":return new gr({mapKey:n,maxSize:s(t)})}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>vo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:Tr}=O;var Rr=function(e){var t;const n=br(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...s}=e,i=yr({...s,key:`${e.key}__${null!==(o=vo(t))&&void 0!==o?o:"void"}`,default:"function"==typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"==typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return n.set(t,i),Tr(i.key,(()=>{n.delete(t)})),i}};const{setConfigDeletionHandler:Ar}=O;let Er=0;var Nr=function(e){var t;const n=br(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(o=vo(t,{allowFunctions:!0}))&&void 0!==o?o:"void"}/${Er++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,u="function"==typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=er({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=er({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return n.set(t,c),Ar(c.key,(()=>{n.delete(t)})),c}};const kr=Nr({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Vr=function(e){return kr(e)};const Lr=Nr({key:"__error",get:e=>()=>{throw new Error(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Mr=function(e){return Lr(e)};var Cr=function(e){return e};const{loadableWithError:Br,loadableWithPromise:Dr,loadableWithValue:Ur}=h;function Ir(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(e){o[r]=e}return[n,o]}function xr(e){return null!=e&&!a(e)}function zr(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Fr(e){return null!=e&&"object"==typeof e&&e.hasOwnProperty("__value")?e.__value:e}function Or(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function Pr(e,t,n){return Or(e,n.map(((e,n)=>null==e?Ur(t[n]):a(e)?Dr(e):Br(e))))}var $r={waitForNone:Nr({key:"__waitForNone",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);return Pr(e,o,r)}}),waitForAny:Nr({key:"__waitForAny",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);return r.some((e=>!a(e)))?Pr(e,o,r):new Promise((t=>{for(const[n,s]of r.entries())a(s)&&s.then((a=>{o[n]=Fr(a),r[n]=void 0,t(Pr(e,o,r))})).catch((a=>{r[n]=a,t(Pr(e,o,r))}))}))}}),waitForAll:Nr({key:"__waitForAll",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);if(r.every((e=>null==e)))return Or(e,o);const a=r.find(xr);if(null!=a)throw a;return Promise.all(r).then((t=>{return Or(e,(n=o,r=t,r.map(((e,t)=>void 0===e?n[t]:e))).map(Fr));var n,r}))}}),waitForAllSettled:Nr({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);return r.every((e=>!a(e)))?Pr(e,o,r):Promise.all(r.map(((e,t)=>a(e)?e.then((e=>{o[t]=Fr(e),r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>Pr(e,o,r)))}}),noWait:Nr({key:"__noWait",get:e=>({get:t})=>{try{return Ur(t(e))}catch(e){return a(e)?Dr(e):Br(e)}}})};const{batchUpdates:Wr,setBatcher:qr}=Ne,{DefaultValue:Gr}=O,{RecoilRoot:jr}=un,{isRecoilValue:Hr}=M,{retentionZone:Kr}=$,{freshSnapshot:Zr}=Ct,{useGotoRecoilSnapshot:Jr,useRecoilCallback:Yr,useRecoilSnapshot:Qr,useRecoilState:Xr,useRecoilStateLoadable:ea,useRecoilTransactionObserver:ta,useRecoilValue:na,useRecoilValueLoadable:oa,useResetRecoilState:ra,useRetain:aa,useSetRecoilState:sa,useSetUnvalidatedAtomValues:ia,useTransactionObservation_DEPRECATED:ua}=oo,{noWait:ca,waitForAll:la,waitForAllSettled:da,waitForAny:fa,waitForNone:ha}=$r;var pa={DefaultValue:Gr,RecoilRoot:jr,useRecoilBridgeAcrossReactRoots_UNSTABLE:lo,atom:yr,selector:er,retentionZone:Kr,atomFamily:Rr,selectorFamily:Nr,constSelector:Vr,errorSelector:Mr,readOnlySelector:Cr,useRecoilValue:na,useRecoilValueLoadable:oa,useRecoilState:Xr,useRecoilStateLoadable:ea,useSetRecoilState:sa,useResetRecoilState:ra,useGetRecoilValueInfo_UNSTABLE:so,useRetain:aa,useRecoilCallback:Yr,useGotoRecoilSnapshot:Jr,useRecoilSnapshot:Qr,useRecoilTransactionObserver_UNSTABLE:ta,useTransactionObservation_UNSTABLE:ua,useSetUnvalidatedAtomValues_UNSTABLE:ia,noWait:ca,waitForNone:ha,waitForAny:fa,waitForAll:la,waitForAllSettled:da,isRecoilValue:Hr,batchUpdates:Wr,setBatcher:qr,snapshot_UNSTABLE:Zr},va=pa.DefaultValue,ya=pa.RecoilRoot,ma=pa.atom,_a=pa.selector,ga=pa.useRecoilValue,Sa=pa.useRecoilState,wa=pa.useRecoilCallback}}]);
//# sourceMappingURL=2804.f9bf1fd3.js.map